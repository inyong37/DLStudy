# :evergreen_tree: 병합 정렬 알고리즘(Merge Sort Algorithm)
기존의 정렬 알고리즘과는 달리 병합 정렬 알고리즘은 이미 정렬되어 있는 데이터들을 하나로 합쳐서 정렬하는 방법이다. 파일에 정렬되어 있는 데이터들을 하나로 합쳐서 정렬하는 경우에도 종종 사용된다. 하드디스크의 용량이 부족하고 지금처럼 대용량의 데이터 저장 장치가 없었던 시절에는 유일한 데이터 백업 장치가 테입 드라이브였다. 테입 드라이브의 특징은 데이터를 처음부터 순차적으로 읽어야 한다는 점이다. 결국 병합 정렬 알고리즘의 특징은 이미 정렬되어 있는 데이터의 그룹 혹은 묶음들을 하나로 합칠 떄 사용하는 방법이 된다.

3개의 서로 다른 데이터 그룹을 하나로 합치는 병합 정렬 알고리즘을 3-way 병합 정렬 알고리즘이라고 하며, 보통의 경우 자주 사용되는 것은 2개의 데이터 그룹을 하나로 합치는 2-way 병합 정렬 알고리즘이다. 하나의 리스트에 저장되어 있는 정렬되지 않는 데이터를 병합 정렬 알고리즘을 사용하는 경우, 정렬되지 있지 않은 데이터들을 정렬하기 위해서 그룹으로 묶는다. 하나의 데이터 리스트를 여러 개로 쪼갠다. 2-way 방식에서는 2개씩 그룹으로 묶는다. 병합을 하기 위한 데이터를 (RUN)이라고 표현한다. 2개의 런을 묶어서 하나의 런으로 합치는 정렬을 하게 된다. 이 다음부터는 모든 데이터가 하나의 런으로 합쳐질 때까지 반복하게 된다. 병합 정렬의 키포인트는 1부터 2의 배수로 하나의 런에 들어가는 데이터의 수를 늘려서 병합하는 과정을 반복한다는 점이다. 이와 같이 반복하여 병합하게 되면 결국 저체 데이터를 모두 정렬하게 되는 결과를 얻을 수 있다.

```Python
def merge_sort(mylist):
  if len(mylist) <= 1: return mylist
  half = len(mylist) // 2
  left_list = merge_sort(mylist[:half]
  right_list = merge_sort(mylist[half:])
  merged_list = []
  
  while len(left_list) > 0 and len(right_list) > 0:
    if left_list[0] > right_list[0]:
      merged_list.append(right_list[0]
      right_list.pop(0)
    else:
      merged_list.append(left_list[0])
      left_list.pop(0)
  
  if len(left_list) > 0: merged_list += left_list
  if len(right_list) > 0: merged_list += right_list
  return merged_list
```

성능은 수치적으로만 보면 퀵 정렬 알고리즘과 비슷하다. 모두 데이터를 분할한 후에 재귀 호출을 사용하기 때문이다.정렬할 데이터가 N개라고 가정하면 데이터를 분할하는데 걸리는 시간은 log2N이 된다. 일단 분할한 후에 2개의 데이터 그룹을 하나로 합치는 데는 O(N)의 시간이 걸린다. 결국 병합 정렬의 성능을 O 표기법으로 표시하면 O(N * log2N)이 된다.

1. 시간의 효율성: O(NlogN)의 실행 시간을 갖아 다른 정렬 알고리즘에 비해서 상당히 빠른 정렬 알고리즘이다. 일반적인 경우에는 빠를지 몰라도 최악의 경우와 같이 이미 정렬이 되어 있는 상태에서는 성능이 급격히 저하된다. 그러나 퀵 정렬 알고리즘이 최악의 경우에 O(N^2)의 성능을 갖는 것에 비하면 오히려 최악의 경우에는 퀵 정렬 알고리즘보다는 나은 정렬 알고리즘이다.
2. 공간의 효율성: 가장 큰 단점이 원래의 데이터 공간 이외에 별도의 데이터 공간이 필요하다는 점이다. 이러한 단점을 극복하는 방법으로는 데이터들을 연결 리스트로 만든 후에 병합 정렬 알고리즘을 사용하는 방법도 있다.
3. 코드의 효율성: 보통의 경우 재귀 호출을 사용한다. 재귀 호출을 사용하면 코드의 길이가 짧아지고 컴팩트(Compact)하다는 장점이 있는 반면에 디버깅이 어렵고 코드를 이애하기 좀 어려워진다는 단점이 있다. 그러한 단점을 피하기 위해 재귀 호출을 사용하지 않고 병합 정렬 알고리즘을 구현할 수도 있다. 그러나 재귀 호출을 사용하는 방식에 비해 코드가 길어지게 된다.

# :palm_tree: 힙 정렬 알고리즘(Heap Sort Algorithm)
